<!--
       * video-tagging control for video tagging
       * Main file of the video-tagging module.
-->

<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="video-taggingstyles.html">
<link rel="import" href="optional-tags.html">
<link rel="import" href="playback-control.html">

<dom-module id="video-tagging">
    <template>
        <style include="video-taggingstyles"></style>
        <link rel="stylesheet" href="css/sliders.css" />
        <link rel="stylesheet" href="../jquery-ui/themes/base/resizable.css">
        <link rel="stylesheet" href="css/imgareaselect-animated.css" />
        <link rel="stylesheet" href="../bootstrap/dist/css/bootstrap.min.css" />
        <link rel="stylesheet" href="assets/icons/style.css">

        <div id="controlWrapper" class="controlWrapper">
            <playback-control id="playSpeedControl" class="playSpeedControl"></playback-control>
            <div id='videoWrapper' class="relativeDiv">
                <div id="ctZone">
                    <div id="toolbarZone">
                        <svg id="toolbarSVG">
                            <defs>
                                <filter id="black-glow">
                                    <feGaussianBlur in="SourceAlpha" stdDeviation="2" />
                                    <feOffset dx="0" dy="0" result="offsetblur" />
                                    <feComponentTransfer>
                                        <feFuncA type="linear" slope="0.8" />
                                    </feComponentTransfer>
                                    <feMerge>
                                        <feMergeNode />
                                        <feMergeNode in="SourceGraphic" />
                                    </feMerge>
                                </filter>
                            </defs>
                        </svg>
                    </div>
                    <div id="selectionZone">
                        <svg id="selectionSVG" class="selectionZoneStyle">
                            <defs>
                                <filter id="black-glow">
                                    <feGaussianBlur in="SourceAlpha" stdDeviation="2" />
                                    <feOffset dx="0" dy="0" result="offsetblur" />
                                    <feComponentTransfer>
                                        <feFuncA type="linear" slope="0.8" />
                                    </feComponentTransfer>
                                    <feMerge>
                                        <feMergeNode />
                                        <feMergeNode in="SourceGraphic" />
                                    </feMerge>
                                </filter>
                            </defs>
                        </svg>
                        <canvas id="overlay" on-click='videoClicked' class="overlaystyle" width="100" height="100">
                            Your browser does not support the HTML5 canvas location.
                        </canvas>
                        <canvas id='frameCanvas' class="frameCanvasStyle" width="100" height="100">

                        </canvas>

                        <video id='vid' class="videoStyle">
                            Your browser does not support the video location.
                        </video>
                    </div>
                </div>
            </div>
            <div id="videoControls" class="videoControls">
                <div id="seekDiv" class="seekWrapper">
                    <input id="seekBar" class="seek clickableControl" type="range" min='0' value="0" step="any"
                        onkeydown="return false;" required />
                </div>
                <table id="videoControlsTable" class="videoControlsTable">
                    <tr>
                        <!-- 回退一帧-->
                        <td class="videoControlCell simpleControl clickableControl">
                            <span id="stepbwd" title="prev" class="icon-backward2 taggingControls" on-click='stepBwdClicked'></span>
                        </td>
                        <!-- 播放、暂停-->
                        <td class="videoControlCell simpleControl clickableControl">
                            <span id="play-pause" title="play/pause" class="icon-play3 taggingControls" on-click='playPauseClicked'></span>
                        </td>
                        <!-- modify-->
                        <!-- 倍速播放控制-->
                        <td class="videoControlCell simpleControl clickableControl">
                            <select id="playSpeed" on-change="playSpeedChange">
                                <option selected="selected" value="1.0">1.0</option>
                                <option value="1.5">1.5x</option>
                                <option value="2.0">2.0x</option>
                                <option value="3.0">3.0x</option>
                                <option value="4.0">4.0x</option>
                            </select>
                        </td>
                        <!-- 前进一帧-->
                        <td class="videoControlCell simpleControl clickableControl">
                            <span id="stepfwd" title="next" class="icon-forward3 taggingControls" on-click='stepFwdClicked'></span>
                        </td>
                        <!-- 跳到下一个未被标记的帧-->
                        <td class="videoControlCell simpleControl clickableControl">
                            <span id="nextuntagged" title="first untagged frame" class="icon-next2 taggingControls"
                                on-click='nextUntaggedClicked'></span>
                        </td>
                        <!-- 去除标记-->
                        <td class="videoControlCell simpleControl clickableControl">
                            <span id="clearRegions" title="clear tags" class="glyphicon glyphicon-ban-circle taggingControls"
                                on-click='clearRegions'></span>
                        </td>
                        <td id="rotate" class="videoControlCell simpleControl clickableControl" style="display: none">
                            <span title="rotate right" class="glyphicon glyphicon-repeat taggingControls" on-click="rotate"></span>
                        </td>
                        <!-- 当前帧数-->
                        <td class="videoControlCell frameNumber">
                            <input type='text' id='frameText' class="textElements" title="frame#"></span>
                        </td>
                        <!-- 
                        总帧数   modify   
                        -->
                        <td class="videoControlCell frameNumber">
                            <span id='frameAllText' class="textElements">共1800帧</span>
                            <!-- <input type='text' id='frameAllText' class="textElements" title="frame#"></span> -->
                        </td>


                        <td id="playSpeedCell" title="play speed" class="videoControlCell longControl clickableControl"
                            style="display: none">
                            <span id="playbackSpan" class="textElements" on-click="playbackSpeedClicked">x 1.0</span>
                        </td>
                        <td nowrap="nowrap" class="videoControlCell simpleControl">
                            <span id="timeSpan" class="textElements"></span>
                        </td>
                        <td class="videoControlCell simpleControl clickableControl" style="display: none">
                            <span id="mute" title="Mute" class="icon-volume-medium taggingControls" on-click='muteClicked'></span>
                        </td>
                        <td class="volumeControlCell longControl" style="display: none">
                            <input id="volumeSlider" class="volume clickableControl" type="range" min=0 max=1 value=.5
                                step=.1 required />
                        </td>

                    </tr>
                </table>
            </div>
            <div id="videoTagControls" class="videoTagControls">
                <div class="optionalTags">
                    <div class="optionalTagsWrapper">
                        <optional-tags id="optionalTags"></optional-tags>
                    </div>
                </div>
                <div class="labelControls">
                    <span id="emptyFrame" title="empty frame" class="icon-share taggingControls controlOff" on-click='emptyFrameClicked'></span>
                    <span id="lockTag" title="lock tags" class="icon-pushpin taggingControls lockTag controlOff"
                        on-click='lockTagsClicked'></span>
                </div>
                <!-- <div class="addTagControls">
                    <form id="addTagForm">
                        <input type="text" id="newTag">
                        <input type="submit" value="Add Tag">
                    </form>
                </div> -->
                <!--modify-->
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                <div>
                    <input type="text" id="trackIdText" size="8">
                    <input type="button" value="生成唯一trackId" on-click="trackIdTextClick" >
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                    <input type="text" id="trackIdLockText" size="8">
                    <input type="button" id="lockTrackIdBtn" value="lock" on-click="lockTrackIdClick">
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                    <font color="white" size="4">From</font>
                    <input type="text" id="startFrame" size="8" placeholder="默认当前帧">
                    <font color="white" size="4">To</font> 
                    <input type="text" id="endFrame" size="8" placeholder="默认总帧数">
                    <font color="white" size="4">TrackId:</font>
                    <input type="text" id="selectTrackId" size="8">
                    <input type="button" id="deleteFrames" value="delete" on-click="deleteFramesClick">
                </div>
                <div style="clear: both">
                </div>
                <div style="clear: both">
                </div>
            </div>
        </div>
    </template>
    <script>
        Polymer({
            is: 'video-tagging',
            properties: {
                framerate: Number,
                videoduration: Number,
                videowidth: Number,
                videoheight: Number,
                regiontype: String,
                multiregions: Number,
                regionsize: Number,
                imagelist: Object,
                inputtagsarray: Object,
                inputframes: Object,
                src: {
                    type: String,
                    value: '',
                    observer: 'videoSrcChanged'
                }
            },
            // Element Lifecycle
            ready: function () {
                const path = require('path');
                this.frames = {}; //Holds the data of the tagged frames, their regions and tags
                this.seeking = false; //Flag for enabling control over the seek bar while the video is playing, see playingCallback function
                this.sequencePlaying = false; //Flag for holding playback state of an image sequence
                this.selectedRegionId = []; //Holds the current selected region number
                this.lockTagsEnabled = false;
                this.selectedTags = [];
                this.uniqueTagId = 0;
                this.videoStartTime = 0; //sometimes videos don't load at absoultue zero
                this.canMove = true;
                this.imageIndex = 0;
                this.curImg = new Image();
                this.rotation = 0;
                this.prevFrameIndex = 0;
                this.multiselection = false;
                this.newTagIndex = null;
                //Frame view size
                this.frameWidth = 0;
                this.frameHeight = 0;
                this.sourceWidth = 0;
                this.sourceHeight = 0;
                //Divs and spans
                this.controlWrapper = this.$$('#controlWrapper');
                this.videoWrapper = this.$$('#videoWrapper');
                this.overlay = this.$$('#overlay');
                this.video = this.$$('#vid');
                this.frameCanvas = this.$$('#frameCanvas');
                this.optionalTags = this.$$('#optionalTags');
                this.regionLabelSpan = this.$$('#regionLabelSpan');
                this.timeSpan = this.$$('#timeSpan');
                this.frameText = this.$$("#frameText");
                
                //modify
                this.trackIdText = this.$$("#trackIdText");
                //this.frameAllText = this.$$("#frameText");
                this.playSpeed = this.$$("#playSpeed");
                this.playbackSpan = this.$$("#playbackSpan");
                this.trackIdValue = 1;
                //标志着trackID是否被锁定，为了创建一系列的相同trackID的region所准备
                this.lockTrackId = false;
                this.lockTrackIdValue = undefined;
                //Form
                // this.form = this.$$('#addTagForm'),
                // Buttons
                this.playButton = this.$$('#play-pause');
                this.stepfwd = this.$$("#stepfwd");
                this.stepbwd = this.$$("#stepbwd");
                this.lockTag = this.$$("#lockTag");
                this.playSpeedControl = this.$$("#playSpeedControl");
                this.playSpeedCell = this.$$("#playSpeedCell");
                this.mute = this.$$('#mute');
                this.emptyFrame = this.$$("#emptyFrame");
                this.nextuntagged = this.$$("#nextuntagged");
                // Sliders
                this.seekBar = this.$$("#seekBar");
                this.volumeSlider = this.$$("#volumeSlider");
                //dynamic styles for sliders
                this.volumeStyle = document.createElement('style');
                Polymer.dom(this.root).appendChild(this.volumeStyle);
                this.seekStyle = document.createElement('style');
                Polymer.dom(this.root).appendChild(this.seekStyle);
                this.playing = null;
                this.ctx = this.overlay.getContext("2d");
                this.aspect = 0;
                this.snapWidth = 0;
                //modify
                this.uniqueTrackValue = 1;
                // Init CanvasTools
                this.initCanvasTools();
            },
            initCanvasTools() {
                this.selectionSVG = document.getElementById("selectionSVG");
                this.toolbarSVG = document.getElementById("toolbarSVG");
                this.CT = CanvasTools.CanvasTools;
                this.regionsManager = new this.CT.Region.RegionsManager(this.selectionSVG, () => { }, () => { });
                this.areaSelector = new this.CT.Selection.AreaSelector(this.selectionSVG,
                    {
                        onSelectionBegin: () => {
                            this.selectionSVG.style.zIndex = 300;
                        },
                        onSelectionEnd: (commit) => {
                            let r = commit.boundRect;
                            this.selectionSVG.style.zIndex = 30;
                            this.onNewAreaSelected(r.x1, r.y1, r.x2, r.y2);
                        },
                        onLocked: () => {
                            this.regionsManager.freeze();
                        },
                        onUnlocked: () => {
                            this.regionsManager.unfreeze();
                        }
                    });
                this.regionsManager.onManipulationEnd = () => {
                    this.areaSelector.enable();
                };
                this.regionsManager.onManipulationBegin = () => {
                    this.areaSelector.disable();
                };
                this.regionsManager.onRegionSelected = (id, multiselection) => {
                    this.selectRegion(id, multiselection);
                };
                this.regionsManager.onRegionMove = (id, x, y, width, height) => {
                    this.regionMoved(id, x, y, width, height);
                };
                this.regionsManager.onRegionDelete = (id) => {
                    this.deleteRegionById(id);
                };
                // Fulfill toolbar
                this.toolbar = new this.CT.Toolbar.Toolbar(toolbarSVG);
                let selectionMode = "rect-select";
                let rectIcont = new this.CT.Toolbar.IconDescription(
                    "rect-select",
                    "public/js/video-tagging/assets/icons/ct/rect-selection.svg",
                    "Rectangular box (R)",
                    'KeyR');
                this.toolbar.addAction(rectIcont, (action) => {
                    this.areaSelector.setSelectionMode(this.CT.Selection.SelectionMode.RECT);
                });
                let copyTemplateIcon = new this.CT.Toolbar.IconDescription(
                    "copy-select",
                    "public/js/video-tagging/assets/icons/ct/copy-t-selection.svg",
                    "Copy-based box (T)",
                    'KeyT');
                this.toolbar.addAction(copyTemplateIcon, (action) => {
                    let rs = this.regionsManager.getSelectedRegionsBounds();
                    if (rs !== undefined && rs.length > 0) {
                        let r = rs[0];
                        this.areaSelector.setSelectionMode(this.CT.Selection.SelectionMode.COPYRECT, { template: new this.CT.Base.Rect.Rect(r.width, r.height) });
                    } else {
                        this.areaSelector.setSelectionMode(this.CT.Selection.SelectionMode.COPYRECT, { template: new this.CT.Base.Rect.Rect(40, 40) });
                    }
                });
                let clickTemplateIcon = new this.CT.Toolbar.IconDescription(
                    "click-select",
                    "public/js/video-tagging/assets/icons/ct/click-selection.svg",
                    "Two-Point Mode (P)",
                    'KeyP');
                this.toolbar.addAction(clickTemplateIcon, (action) => {
                    //right now this just does what the first icon does
                    this.areaSelector.setSelectionMode(this.CT.Selection.SelectionMode.RECT);
                });
                let selectionLockIcon = new this.CT.Toolbar.IconDescription(
                    "selection-lock",
                    "public/js/video-tagging/assets/icons/ct/selection-lock.svg",
                    "Lock/unlock selection (L)",
                    'KeyL',
                    true);
                this.toolbar.addAction(selectionLockIcon, (action) => {
                    this.areaSelector.toggleLockState();
                });
                this.toolbar.select("rect-select");
                // Register empty filter pipeline
                this.filterPipeline = new this.CT.Filter.FilterPipeline();;
            },
            /**
               * Events registration and handling
               *
               * @method attached
               * Events registration and handling
               */
            attached: function () {
                //Reset all variables to new src
                this.video.addEventListener("loadedmetadata", init);
                var self = this;
                function init() {
                    self.controlWrapper.style.display = "grid";
                    //Init variables and controls
                    self.frames = self.inputframes ? self.inputframes : {};
                    //console.log(self.frames)
                    self.frameTime = 1 / self.framerate;
                    //console.log(self.frameTime)
                    //modify
                    //设置总帧数
                    //video.duration 返回视频的长度，以秒计
                    $("#frameAllText").html("共" + Math.ceil(self.video.duration * self.framerate) + "帧");
                    self.optionalTags.createTagControls(self.inputtagsarray);
                    //Take the raw video aspect ratio
                    self.sourceWidth = self.video.videoWidth;
                    self.sourceHeight = self.video.videoHeight;
                    self.aspect = self.sourceWidth / self.sourceHeight;
                    //self.snapToAspectRatio();
                    //Init sliders
                    self.volumeSlider.value = 0.5;
                    self.seekBar.max = self.video.duration;
                    // Update frame size to video size     
                    self.resetLayout();
                    let scaleByPortrait = ((videotagging.video.offsetWidth / videotagging.video.offsetHeight) >= self.aspect);
                    self.resizeFrame(scaleByPortrait, self.aspect);
                    self.playingCallback();
                    //fix resize bug
                    $(window).off("resize");
                    $(window).resize(function () {
                        if (self.video.offsetWidth !== undefined) {
                            //self.snapToAspectRatio();
                            // Update frame size to video size  
                            self.resetLayout();
                            let scaleByPortrait = ((videotagging.video.offsetWidth / videotagging.video.offsetHeight) >= self.aspect);
                            self.resizeFrame(scaleByPortrait, self.aspect);
                            //resize the region boxes
                            // self.showAllRegions();                    
                        }
                    });
                    //bind keys (note this currently overrides any listener on the parent controls needs a more elegant way to work only when control is in focus)
                    if (self.keyUpEventsListenerBinded != null) {
                        window.removeEventListener("keyup", self.keyUpEventsListenerBinded);
                    }
                    self.keyUpEventsListenerBinded = self.keyUpEventsListener.bind(self);
                    window.addEventListener("keyup", self.keyUpEventsListenerBinded, false);
                }
                this.video.onended = function () {
                    self.pauseState();
                };
                this.video.addEventListener('canplaythrough', function () {
                    self.updateFrameCanvas(self.video);
                    /* window.requestAnimationFrame(function(){
                        self.frameCanvas.getContext('2d').drawImage(self.video, 0, 0, self.frameWidth, self.frameHeight);
                        }); */
                });
                this.seekBar.addEventListener("mousedown", function () {
                    self.seeking = true;
                });
                this.seekBar.addEventListener("mouseup", function () {
                    self.seeking = false;
                });
                this.seekBar.addEventListener("change", function () {
                    self.seeking = false;
                    if (self.imagelist) { //image list handling
                        var seekToFrameId = Math.floor(self.seekBar.value);//keep the frame in sync
                        self.seekToFrame(seekToFrameId);
                    } else { //video handling
                        self.video.currentTime = Math.floor(self.seekBar.value / self.frameTime) * self.frameTime;//keep the frame in sync 
                    }
                    self.playingCallback();
                });
                this.volumeSlider.addEventListener("change", function () {
                    if (!self.imagelist) {
                        self.video.volume = self.volumeSlider.value;
                        var perc = 100 * self.volumeSlider.value / self.volumeSlider.max;
                        self.volumeStyle.textContent = '.volume::-webkit-slider-runnable-track{background-size:' + perc + '% 100%} ';
                        self.volumeStyle.textContent += '.volume::-moz-range-track{background-size:' + perc + '% 100%} ';
                    }
                });
                this.frameText.addEventListener("keydown", self.frameInputListener);
                this.frameText.addEventListener("keyup", self.frameInputListener);
                this.frameText.addEventListener("input", function (event) {
                    //modify
                    if (self.imagelist) {
                        if (self.frameText.value > 0 && self.frameText.value <= self.imagelist.length) {
                            var seekToFrameId = Math.min(self.imagelist.length, self.frameText.value);//keep the frame in sync
                            self.seekToFrame(seekToFrameId - 1);
                        }
                    } else {
                        //modify
                        console.log("self.video.duration: " + self.video.duration);
                        console.log("self.framerate: "+self.framerate)
                        console.log("self.video.duration * self.framerate:" + self.video.duration * self.framerate);

                        if (self.frameText.value > 0 && self.frameText.value <= (self.video.duration * self.framerate)) {
                            console.log("self.frameTime:"+self.frameTime)
                            console.log("self.videoStartTime:"+self.videoStartTime)
                            self.video.currentTime = ((self.frameText.value - 1) * self.frameTime) + self.videoStartTime;
                            console.log("self.video.currentTime :" + self.video.currentTime);
                        }
                    }
                    self.playingCallback();
                    event.stopPropagation();
                });
                //modify
                this.trackIdText.addEventListener("keydown",function(){});
                this.trackIdText.addEventListener("keyup",function(){});
                this.trackIdText.addEventListener("input",function(){});
                this.addEventListener("playSpeedSelected", function (e) {
                    self.playback(e.detail.playbackValue, e.detail.playbackText);
                });
                this.addEventListener("ontagschanged", (tagsStateEvent) => {
                    let tags = tagsStateEvent.detail.selected;
                    let currentRegionUID = this.selectedRegionId[0];
                    let region = this.getRegionById(currentRegionUID);
                    if (tags.length > 0 && region != null) {
                        let tagsDescriptor = this.buildTagsDescriptor(tags);
                        region.tags = tags;
                        this.regionsManager.updateTagsById(currentRegionUID, tagsDescriptor);
                    } else {
                        region.tags = [];
                        this.regionsManager.updateTagsById(currentRegionUID, null);
                    }
                    this.selectRegion(currentRegionUID)
                });
                // this.form.addEventListener("submit", function (e) {
                //     //$("#newTags").val("45");
                //     //document.getElementById("newTag").value = 45;
                //     // e.preventDefault();
                //     // newTag = document.getElementById("newTag").value;
                //     // self.inputtagsarray.push(newTag);
                //     // self.optionalTags.createTagControls(self.inputtagsarray);
                //     // self.showAllRegions();
                // })
            },
            frameInputListener: function (event) {
                event.stopPropagation();
            },
            keyUpEventsListener: function (e) {
                switch (e.keyCode) {
                    case 37:  // left
                        if (!e.ctrlKey) {
                            this.stepBwdClicked();
                        }
                        break;
                    case 39: // right
                        if (!e.ctrlKey) {
                            this.stepFwdClicked();
                        }
                        break;
                    case 32:// space to toggle play/pause
                        this.playPauseClicked();
                        break;
                    // case 68:// d for duplicate
                    //     if (e.ctrlKey) break;
                    //     let frameId = this.getCurrentFrameId();
                    //     if (this.imagelist) {
                    //         frameId = this.imageIndex
                    //     }
                    //     if (frameId > 0) {
                    //         this.frames[this.getCurrentFrameId()] = this.getPrevFrameRegionsCopy();
                    //     }
                    //     this.playingCallback();
                    //     break;
                   
                    // case 81:// q to go back a frame
                    //     if (!e.ctrlKey) {
                    //         this.stepBwdClicked();
                    //     }
                    //     break;
                    // case 69:// e to go forward a frame
                    //     if (!e.ctrlKey) {
                    //         this.stepFwdClicked();
                    //     }
                    //     break;
                    default: return; // exit this handler for other keys
                }
                e.preventDefault(); // prevent the default action (scroll / move caret)
            },
            keyUpEventsListenerBinded: null,
            onNewAreaSelected: function (x1, y1, x2, y2) {
                //modify
                console.log("onNewAreaSelected start")
                document.getElementById("trackIdText").value = "";
                //document.getElementById("trackIdLockText").value = this.lockTrackIdValue ? this.lockTrackIdValue : "";
                var threshold = 20;
                var dx, dy;
                var r = {};
                if (x1 < x2) {
                    r.x1 = x1;
                    r.x2 = x2;
                } else {
                    r.x1 = x2;
                    r.x2 = x1;
                }
                if (y1 < y2) {
                    r.y1 = y1;
                    r.y2 = y2;
                } else {
                    r.y1 = y2;
                    r.y2 = y1;
                }
                dx = Math.abs(x1 - x2);
                if (dx < threshold) {
                    dx = (threshold - dx) / 2
                    r.x1 = Math.max(0, r.x1 - dx);
                    r.x2 = Math.min(this.frameWidth, r.x2 + dx);
                }
                dy = Math.abs(y1 - y2);
                if (dy < threshold) {
                    dy = (threshold - dy) / 2
                    r.y1 = Math.max(0, r.y1 - dy);
                    r.y2 = Math.min(this.frameHeight, r.y2 + dy);
                }
                this.createRegion(r.x1, r.y1, r.x2, r.y2);
            },
            generateUniqueId: function () {
                return Math.floor((1 + Math.random()) * 0x100000000)
                    .toString(16)
                    .substring(1);
            },
            getRegions: function (frameId) {
                let regions = null;
                if (frameId || frameId == 0) {
                    regions = this.frames[frameId];
                    if (regions == undefined || regions == null) {
                        this.frames[frameId] = [];
                        regions = this.frames[frameId];
                    }
                }
                return regions;
            },
            getCurrentFrameNumber: function () {
                if (this.imagelist) {
                    return this.imageIndex;
                }
                return this.video.currentTime === 0 ? 1 : Math.ceil((this.video.currentTime - this.videoStartTime) * this.framerate) + 1;
            },
            getCurrentFrameId: function () {
                if (this.imagelist) {
                    return (this.imagelist[this.imageIndex].split(path.sep).pop());
                }
                return this.video.currentTime === 0 ? 1 : Math.ceil((this.video.currentTime - this.videoStartTime) * this.framerate) + 1;
            },
            getCurrentFrameRegions: function () {
                return this.getRegions(this.getCurrentFrameId());
            },
            getSelectedRegions: function () {
                return this.selectedRegionId.map(x => this.getRegionById(x))
            },
            getPrevFrameRegionsCopy: function () {
                if (this.imagelist) {
                    return JSON.parse(JSON.stringify(this.getRegions(this.imagelist[this.prevFrameIndex].split(path.sep).pop())));
                } else {
                    return JSON.parse(JSON.stringify(this.getRegions(this.prevFrameIndex)));
                }
            },
            getRegionById: function (regionUID) {
                let region = null;
                let regions = this.getCurrentFrameRegions();
                let i = 0;
                while (i < regions.length && region == null) {
                    if (regions[i].UID == regionUID) {
                        region = regions[i];
                    }
                    i++
                }
                return region;
            },
            
            createRegion: function (x1, y1, x2, y2) {
                let widthRatio = this.overlay.width / this.sourceWidth;
                let heightRatio = this.overlay.height / this.sourceHeight;
                var rx1 = x1 / widthRatio;
                var ry1 = y1 / heightRatio;
                var rx2 = x2 / widthRatio;
                var ry2 = y2 / heightRatio;
                var region = this.addRegion(rx1, ry1, rx2, ry2);//Add to in-memory collection
                //modify
                if(document.getElementById("trackIdText").value) {
                    region.trackId = document.getElementById("trackIdText").value;
                }
                
                //modify
                console.log("create region region.tags")
                console.log(region.tags)
                this.registerRegion(x1, y1, x2, y2, region.UID, region.tags); //add frame
                //if there is only one tag enable it by default
                if ($(`#${this.optionalTags.id}`).find('.tagButtons').size() == 1) {
                    $(`#${this.optionalTags.id}`).find('.tagButtons')[0].click();
                }
                if (this.lockTagsEnabled) {
                    //Get all selected tags and add them to current region automatically
                    //this.selectedTags was populated in this.lockTagsClicked
                    var arr = [];
                    for (var i = 0; i < this.selectedTags.length; i++) {
                        this.optionalTags.setSelected(this.selectedTags[i]);
                        arr.push(this.selectedTags[i].id);
                    }
                    this.addTagsToRegion(arr);
                    var self = this;
                    //Auto step functionality - Goes to next frame automatically
                    if (this.multiregions === "0") {
                        setTimeout(function () { self.stepFwdClicked(); }, 500);
                    }
                }
                //this.emitRegionToHost();//Persist
            },
            //Adds new tags found in tfrecord to tags array
            addNewRecordTags: function () {
                let recs = []
                for (let tag of this.currTFRecord.features.feature["image/object/class/text"].bytesList.value) {
                    if (!this.inputtagsarray.includes(String.fromCharCode.apply(null, tag))) recs.push(String.fromCharCode.apply(null, tag));
                }
                if (recs.length) this.inputtagsarray.push.apply(this.inputtagsarray, recs)
            },
            checkRemovedTags: function () {
                let regions = this.getCurrentFrameRegions();
                regions.forEach(region => region.tags.forEach(tag => {
                    if (!this.inputtagsarray.includes(tag)) {
                        region.tags.splice(tag, 1);
                    }
                }));
            },
            buildTagsDescriptor: function (tags,regionUID) {
                let region = this.getRegionById(regionUID);
                
                //modify
                let tid = document.getElementById("trackIdText").value;
                // 如果region有trackId且trackIdText内无内容，使用trackIdLockText内的值
                if(this.lockTrackId) {
                    tid = document.getElementById("trackIdLockText").value;
                }
                //modify
                console.log("tid: "+tid)
                let tagsDescriptor = null;
                let primaryTag = null;
                let secondaryTags = [];
                if (tags.length > 0) {
                    let color = this.optionalTags.colors[this.inputtagsarray.indexOf(tags[0])];
                    console.log("build tags")
                    console.log(tags)
                    
                    if(tags[0] == "face" || tags[0] == "person"){
                        primaryTag = new this.CT.Base.Tags.Tag(tags[0], this.CT.Base.Tags.Tag.getHueFromColor(color) * 360); 
                    } else {
                        return null;
                    }
                    
                    secondaryTags = [];
                    // for (var i = 1; i < tags.length; i++) {
                    //     let c = this.optionalTags.colors[this.inputtagsarray.indexOf(tags[i])];
                    //     let t = new this.CT.Base.Tags.Tag(tags[i], this.CT.Base.Tags.Tag.getHueFromColor(c) * 360);
                    //     secondaryTags.push(t)
                    // }
                    console.log("primaryTag.name")  
                    if(tid) {
                        primaryTag.name = tid;
                        // primaryTag.name = primaryTag.name + tid;
                        if(!this.lockTrackId) {
                            this.trackIdValue ++;
                        }  
                    }
                    if(region != null) {
                        primaryTag.name = region.trackId;
                        // primaryTag.name = primaryTag.name + region.trackId;
                    }
                    console.log("primaryTag");
                    console.log(primaryTag)
                    tagsDescriptor = new this.CT.Base.Tags.TagsDescriptor(primaryTag, secondaryTags);
                }
                return tagsDescriptor;
            },
            addTagsToRegion: function (selectedTagsArray) {
                console.log("addTagsToRegion start");
                let currentRegion = this.selectedRegionId[0];
                let region = this.getRegionById(currentRegion);
                if (region != null) {
                    let tags = region.tags;
                    //modify
                    console.log(tags)
                    for (var i = 0; i < selectedTagsArray.length; i++) {
                        tags.push(selectedTagsArray[i]);
                    }
                    if (tags.length > 0) {
                        let tagsDescriptor = this.buildTagsDescriptor(tags);
                        //modify
                        //console.log(tagsDescriptor)
                        this.regionsManager.updateTagsById(region.UID, tagsDescriptor);
                        //console.log(tagsDescriptor)
                    } else {
                        this.regionsManager.updateTagsById(region.UID, null);
                    }
                }
            },
            nextUntaggedClicked: function () {
                if (this.checkRegionLabels()) {
                    var frameIndex = this.getCurrentFrameRegions();
                    if (this.imagelist) {//image handling
                        var lastTagIndex = parseInt(Object.keys(this.frames)[Object.keys(this.frames).length - 1])
                        if (this.imageIndex < this.imagelist.length) {
                            if (lastTagIndex <= frameIndex) {
                                this.imageIndex++;
                            } else {
                                this.imageIndex = lastTagIndex;
                            }
                            this.changeImage(`url(file://${this.imagelist[this.imageIndex].replace(/\\/g, "/")})`);
                            this.playingCallback();
                        }
                    } else { //video handling
                        var lastTagIndex = Object.keys(document.getElementById("video-tagging").frames).length;
                        var nextFrameOffset = Math.max((lastTagIndex - frameIndex), 1);
                        if (!this.video.paused) this.pauseState();
                        if ((this.video.currentTime + this.frameTime) > this.video.duration) {
                            return;
                        }
                        if (!this.canMove) return;
                        //if there are no unlabled tags move to next frame
                        this.video.currentTime += this.frameTime * (nextFrameOffset);
                        this.playingCallback();
                    }
                }
            },
            //modify
            deleteFramesClick: function(){
                //startFrame,endFrame
                var startValue = $("#startFrame").val() ? $("#startFrame").val() : $("#frameText").val();
                var allFrames = $("#frameAllText").html().replace("共","").replace("帧","");
                var endValue = $("#endFrame").val() ? $("#endFrame").val() : allFrames;
                var selectDeleteTrackId =  $("#selectTrackId").val() ? $("#selectTrackId").val() : "";
                


                // if(endValue == "") {
                //     alert("未填写结束帧");
                //     return ;
                // }
                if(selectDeleteTrackId == ""){
                    alert("未填写trackId");
                    return;
                }

                startF = parseInt(startValue);
                endF = parseInt(endValue);
                frameAllTextValue = parseInt(allFrames)

                
                console.log("selectDeleteTrackId" + selectDeleteTrackId)
                //判断输入的结束帧是否超过视频总帧数
                console.log("`````````````````````````````````````");
                console.log("endF:  " + endF + "  frameAllTextValue: " + frameAllTextValue)
                if(endF <= frameAllTextValue) {
                    var yes = confirm("确认删除第 "+startF+" 帧到第 "+endF+" 帧，trackId为："+ selectDeleteTrackId + " 的标注结果吗？");
                    for(var i = startF;i <= endF ; i++) {
                        //将符合条件的去除并重新赋值
                        if(this.frames[i]) {
                            this.frames[i] = this.frames[i].filter((region) => { 
                                return parseInt(region.trackId) != parseInt(selectDeleteTrackId) 
                            });
                        }                        
                    }
                    //重绘所有region
                    this.showAllRegions();
                    $("#selectTrackId").val("");
                } else {
                    alert("结束帧大于视频总帧")
                }  
            },
            trackIdTextClick: function (){
                //console.log("click")
                if(document.getElementById("trackIdText").value.indexOf("set") == 0) {
                    console.log("this string start with set");
                    var value = document.getElementById("trackIdText").value.substring(3).replace(/(^\s*)|(\s*$)/g, ''); 
                    this.trackIdValue = parseInt(value);
                }
                document.getElementById("trackIdText").value = this.trackIdValue;
                //Number(Math.random().toString().substr(3,length) + Date.now()).toString(36);
            },
            lockTrackIdClick :function (){
                this.lockTrackId = !this.lockTrackId;
                if(this.lockTrackId){
                    $("#lockTrackIdBtn").css({
                        "color" : "red",
                        "background-color":"black"
                    });
                } else {
                    $("#lockTrackIdBtn").css({
                        "color": "black",
                        "background-color":"white"
                    });
                    document.getElementById("trackIdLockText").value = "";
                }
                
            },
            lockTagsClicked: function () {
                var selTags = this.optionalTags.getSelectedTags();
                //There has to be selected label/s
                if (!this.lockTagsEnabled && selTags.length > 0) {
                    this.lockTagsEnabled = true;
                    this.selectedTags = selTags;
                    if (this.multiregions === "0") { this.stepFwdClicked(); }
                }
                else {
                    this.lockTagsEnabled = false;
                    this.selectedTags = [];
                    this.optionalTags.resetSelected();
                }
                this.lockTag.classList.toggle("controlOn", this.lockTagsEnabled);
                this.lockTag.classList.toggle("controlOff", !this.lockTagsEnabled);
            },
            regionMoved: function (id, x, y, width, height) {
                let region = this.getRegionById(id);
                let widthRatio = this.overlay.width / this.sourceWidth;
                let heightRatio = this.overlay.height / this.sourceHeight;
                var rx1 = x / widthRatio;
                var ry1 = y / heightRatio;
                var rx2 = (x + width) / widthRatio;
                var ry2 = (y + height) / heightRatio;
                // back compatibility for v < 2.0
                region.x1 = rx1;
                region.y1 = ry1;
                region.x2 = rx2;
                region.y2 = ry2;
                region.width = this.sourceWidth;
                region.height = this.sourceHeight;
                // coordinates for v 2.0+
                region.box = {
                    x1: rx1,
                    y1: ry1,
                    x2: rx2,
                    y2: ry2
                }
                this.buildTagsDescriptor(region.tags,region.UID);
            },
            selectRegion: function (id, multiselection = false) {
                //modify
                // console.log("select Region" + id);
                if (!this.multiselection && !multiselection) {
                    this.cleanSelectedElements();
                }
                //Tags - display the tags of the region and enable editing
                this.optionalTags.toggleEnableButtons(true);
                this.optionalTags.resetSelected();
                if (id != "") {
                    let region = this.getRegionById(id);
                    
                    let tid = document.getElementById("trackIdText").value;
                    if(this.lockTrackId) {
                        tid = document.getElementById("trackIdLockText").value;
                    }
                    if(tid && !region.trackId){
                        // console.log("tid")
                        // console.log(tid)
                        region.trackId =  tid;
                    }
                    document.getElementById("trackIdText").value = "";
                    if(this.lockTrackId && region.trackId) {
                        if(document.getElementById("trackIdLockText").value == "") {
                            document.getElementById("trackIdLockText").value = region.trackId ? region.trackId : "";
                            this.lockTrackIdValue = document.getElementById("trackIdLockText").value;
                        }
                    }
                    console.log("selectRegion ")
                    console.log(region)
                    if (region && !this.selectedRegionId.includes(region.UID)) {
                        this.selectedRegionId.push(id);
                        var tags = region.tags;
                        this.optionalTags.displaySelectedTags(tags);
                    }
                    
                }
            },
            selectAllRegions: function () {
                for (let region of this.getCurrentFrameRegions()) {
                    this.selectRegion(region.UID, true);
                }
            },
            deleteRegionById: function (id) {
                var regions = this.getCurrentFrameRegions();
                this.frames[this.getCurrentFrameId()] = regions.filter((r) => { return r.UID != id; });
                //this.emitRegionToHost();        
                if (id == this.selectedRegionId[0]) {
                    this.selectedRegionId = [];
                }
            },
            clearRegions: function (e) {
                this.frames[this.getCurrentFrameId()] = [];
                this.clearAllRegions();
                // this.showAllRegions();
                //this.emitRegionToHost();
            },
            /**
               * @method emitRegionToHost
               * Fires an event to send the array of regions.
               * The host html page can listen to this event.
               */
            //emitRegionToHost: function() {
            //      this.fire('onregionchanged', {frame: {frameIndex: this.getCurrentFrameId(), regions:this.getCurrentFrameRegions()}});
            //},
            /**
               * @method addDivToRegion
               * Adds a transparent div to the region, the size of the region.
               * Used for click events, hover, etc..
               */
            registerRegion: function (x1, y1, x2, y2, regionUID, tags) {
                // Regions Manager
                let tagsDescriptor = this.buildTagsDescriptor(tags,regionUID);
                // if(tagsDescriptor == null){
                //     return;
                // }
                this.regionsManager.addRegion(regionUID, { x: x1, y: y1 }, { x: x2, y: y2 }, tagsDescriptor);
                this.selectRegion(regionUID);
            },
            /**
               * @method cleanSelectedElements
               * Removes all borders of regions and disables label buttons
               */
            cleanSelectedElements: function () {
                //Remove selected style
                var regionCanvases = Polymer.dom(this.root).querySelectorAll('.regionCanvas');
                for (var i = 0; i < regionCanvases.length; i++) {
                    regionCanvases[i].classList.remove('regionCanvasSelected');
                }
                //reset
                this.selectedRegionId = [];
                this.optionalTags.toggleEnableButtons(false);
                this.optionalTags.resetSelected();
            },
            clearAllRegions: function () {
                // Regions Manager
                this.regionsManager.deleteAllRegions();
                // ** Old code **
                this.clearFrameElements();//Clear canvas and tags
                this.cleanSelectedElements();//Clear selected regions
            },
            showAllRegions: function () {
                this.clearAllRegions();
                var regions = this.getCurrentFrameRegions();
                if (regions && regions.length > 0) {
                    this.checkRemovedTags();
                    //Draw all regions for this frame
                    for (var i = 0; i < regions.length; i++) {
                        var region = regions[i];
                        // console.log("IIIIIIIIII" + i)
                        // console.log(region)
                        //Frame was tagged as empty?
                        if (Object.keys(region).length === 0) {
                            this.indicateEmptyFrame(true);
                            continue;
                        }
                        var widthRatio = this.overlay.width / this.sourceWidth;
                        var heightRatio = this.overlay.height / this.sourceHeight;
                        let x1, y1, x2, y2;
                        if (region.box != undefined) {
                            // onscreen coordinates
                            x1 = (region.box.x1 * widthRatio);
                            y1 = (region.box.y1 * heightRatio);
                            x2 = (region.box.x2 * widthRatio);
                            y2 = (region.box.y2 * heightRatio);
                        } else {
                            // restore absolute coordinates
                            let wRatio = this.sourceWidth / region.width;
                            let hRatio = this.sourceHeight / region.height;
                            x1 = (region.x1 * wRatio);
                            y1 = (region.y1 * hRatio);
                            x2 = (region.x2 * wRatio);
                            y2 = (region.y2 * hRatio);
                            region.box = {
                                x1: x1,
                                y1: y1,
                                x2: x2,
                                y2: y2
                            };
                            //onscreen coordinates
                            x1 = x1 * widthRatio;
                            y1 = y1 * heightRatio;
                            x2 = x2 * widthRatio;
                            y2 = y2 * heightRatio;
                        }
                        if (region.UID == undefined) {
                            region.UID = this.generateUniqueId();
                        }
                        
                        //modify
                        // console.log("region.tags showAllRegions")
                        // console.log(region.tags)
                        // var myTags = region.tags;
                        // myTags[1] = region.trackId;
                        this.registerRegion(x1, y1, x2, y2, region.UID, region.tags);; //add frame 
                        
                    }
                    //Redraws all regions to ensure proper z-order stacking
                    this.regionsManager.redrawAllRegions();
                }
                //Clears areaSelector state when moving across frames
                this.regionsManager.onManipulationEnd();
            },
            /**
               * @method addRegion
               * Adds a region to the array of regions per current frame.
               * @params {x1, y1, x2, y2} region coordinates.
               */
            addRegion: function (x1, y1, x2, y2) {
                this.resetEmptyFrame();//Clear empty frame logic
                
                var region = {
                    // relative for back compatiblity (v < 2.0)
                    x1: x1,
                    y1: y1,
                    x2: x2,
                    y2: y2,
                    width: this.sourceWidth,
                    height: this.sourceHeight,
                    // absolute coordinates - new (v 2.0+)
                    box: {
                        x1: x1,
                        y1: y1,
                        x2: x2,
                        y2: y2
                    },
                    UID: this.generateUniqueId(),
                    //modify
                    trackId: undefined,
                    id: this.uniqueTagId++,
                    type: this.regiontype,
                    tags: []
                };
                var regions = this.getCurrentFrameRegions();
                //modify
                console.log(regions)
                //The array is populated and can contain multiple regions
                if (this.multiregions == 1 && regions) {
                    region.name = regions.length + 1;
                    regions.push(region);
                }
                else {//Only one region allowed
                    this.clearFrameElements();
                    region.name = 1;
                    regions = [];
                    regions.push(region);
                }
                return region;
            },
            /**
               * All functions related to frames management
               *
               * @method clearFrameElements
               * Clears all drawings and divs from the video area and resets tag controls.
               */
            clearFrameElements: function () {
                //Clear divs
                $(this.videoWrapper).children(".regionCanvas").remove();
                //reset tag buttons to not selected
                this.optionalTags.resetSelected();
                //Clears the empty frame icon
                this.indicateEmptyFrame(false);
            },
            indicateEmptyFrame: function (selected) {
                if (selected) {
                    this.emptyFrame.classList.remove("controlOff");
                    this.emptyFrame.classList.add("controlOn");
                }
                else {
                    this.emptyFrame.classList.remove("controlOn");
                    this.emptyFrame.classList.add("controlOff");
                }
            },
            /**
               * @method emptyFrameClicked
               * Creates an empty region array for the current frame, meaning that the frame is not tagged, but has been reviewed.
               */
            emptyFrameClicked: function () {
                var regions = this.getCurrentFrameRegions();
                if (!regions || regions.length === 0) {
                    this.frames[frameIndex] = [{}];
                    this.indicateEmptyFrame(true);
                    // this.emitRegionToHost();
                    if (this.lockTagsEnabled) {
                        this.stepFwdClicked();
                    }
                }
            },
            /**
               * @method resetEmptyFrame
               * If the frame has been marked as empty - reset that.
               */
            resetEmptyFrame: function () {
                var regions = this.frames[this.getCurrentFrameId()];
                //If there is an empty region
                if (regions && regions.length === 1 && Object.keys(regions[0]).length === 0) {
                    //reset all for this frame
                    this.frames[this.getCurrentFrameId()] = [];
                    this.clearFrameElements();
                }
            },
            /**
               * Video management
               *
               */
            muteClicked: function () {
                this.mute.classList.toggle("icon-volume-mute2", !this.video.muted);
                this.mute.classList.toggle("icon-volume-medium", this.video.muted);
                this.video.muted = !this.video.muted;
            },
            /**
               * Handler for setting the video play speed
               */
            playback: function (val, text) {
                if (val !== null) {
                    this.video.playbackRate = val;
                    this.playbackSpan.innerHTML = text;
                }
                this.playSpeedControl.style.display = "block";
            },
            //modify
            //添加播放速度控制监听
            playSpeedChange: function () {
                this.video.playbackRate = $("#playSpeed").val();
                this.video.play();
            },
            /**
               * Shows the play speed control
               */
            playbackSpeedClicked: function () {
                var offset = $('#playSpeedCell').offset();
                var top = offset.top - $('#playSpeedControl').height();
                var left = offset.left + $('#playSpeedCell').width() / 4;
                $('#playSpeedControl').css({ 'left': left, 'top': top });
                this.playSpeedControl.style.display = this.playSpeedControl.style.display === "block" ? "none" : "block";
            },
            playPauseClicked: function () {
                if (this.imagelist) //Play back image sequence
                {
                    this.sequencePlaying ? this.pauseState() : this.playState();
                } else { //Play back video
                    this.video.paused ? this.playState() : this.pauseState();
                }
            },
            getUnlabeledRegionTags: function (regionId) {
                var regions = this.frames[regionId];
                var unlabledTags = [];
                if (regions !== undefined) {
                    unlabledTags = regions.map(function (region, index) {
                        if (!region.tags.length > 0) return index + 1;
                    }).filter(Number.isInteger);
                }
                return unlabledTags;
            },
            //查看当前帧是否有未tag的region
            checkRegionLabels: function () {
                var unlabledTags = this.getUnlabeledRegionTags(this.getCurrentFrameId());
                if (unlabledTags.length > 0) {
                    alert(`Cannot move to the next frame until all tags are labeled. Please label the following tags [${unlabledTags}] on the displayed frame.`);
                    return false;
                }
                //modify 判断当前帧 region是否有非person、face的标签
                var regons = this.frames[this.getCurrentFrameId()];
                var len = regons.length;
                console.log("length" + len)
                for(var i=1;i<len;i++) {
                    // console.log("regons.tags[0]");
                    // console.log(regons[i].tags[0]);
                    // console.log(regons[i].tags[0] == "face");
                    if (regons[i].tags[0] != "face" && regons[i].tags[0] != "person"){
                        return false;
                    }
                }
                
                return true;
            },
            //used for init of image directory find way to reduce duplicate code
            initImageDir: function () {
                if (!this.imagelist) {
                }
                //$("#rotate").show();
                if (this.recordlist) { this.currTFRecord = this.recordlist[0]; this.changeImage(this.currTFRecord.features.feature['image/encoded'].bytesList.value[0], true); }
                else this.changeImage(`url(file://${this.imagelist[this.imageIndex].replace(/\\/g, "/")})`);
                console.log(`url(file://${this.imagelist[this.imageIndex].replace(/\\/g, "/")})`);
                var self = this;
                self.frames = self.inputframes ? self.inputframes : {};
                if (this.currTFRecord) this.addNewRecordTags();
                self.optionalTags.createTagControls(this.inputtagsarray);
                //self.resetLayout();
                //bind keys (note this currently overrides any listener on the parent controls needs a more elegant way to work only when control is in focus)
                if (self.keyUpEventsListenerBinded != null) {
                    window.removeEventListener("keyup", self.keyUpEventsListenerBinded);
                }
                self.keyUpEventsListenerBinded = self.keyUpEventsListener.bind(self);
                window.addEventListener("keyup", self.keyUpEventsListenerBinded, false);
            },
            changeImage: function (imageUrl, isRecord = false) {
                if (isRecord) {
                    let base64Data = btoa(new Uint8Array(imageUrl).reduce(function (data, byte) {
                        return data + String.fromCharCode(byte);
                    }, ''));
                    this.video.style.backgroundImage = encodeURI('data:image/png;base64,' + { base64Data });
                    this.curImg.src = `${'data:image/png;base64,' + base64Data}`;
                } else {
                    this.video.style.backgroundImage = encodeURI(imageUrl);
                    this.curImg.src = `${this.imagelist[this.imageIndex]}`;
                }
                this.rotation = 0;
                var self = this;
                self.curImg.onload = function () {
                    self.controlWrapper.style.display = "grid";
                    self.sourceWidth = self.curImg.width;
                    self.sourceHeight = self.curImg.height;
                    self.aspect = self.sourceWidth / self.sourceHeight;
                    //Size canvas as image
                    let scaleByPortrait = ((videotagging.video.offsetWidth / videotagging.video.offsetHeight) >= self.aspect);
                    self.resizeFrame(scaleByPortrait, self.aspect);
                    //Init variables and controls
                    self.playingCallback();
                    //fix resize bug
                    $(window).off("resize");
                    $(window).resize(function () {
                        if (self.video.offsetWidth !== undefined) {
                            //self.snapToAspectRatio();
                            let scaleByPortrait = ((videotagging.video.offsetWidth / videotagging.video.offsetHeight) >= self.aspect);
                            self.resizeFrame(scaleByPortrait, self.aspect);
                            //resize the region boxes
                            //self.showAllRegions();
                            //reposition selectedRegion Label
                            self.playingCallback();
                        }
                    });
                }
            },
            resizeFrame(isPortrait, imgRatio) {
                if (isPortrait) {
                    this.resizeFrameSize(parseFloat(this.video.offsetHeight * imgRatio), this.video.offsetHeight);
                    //shift the overlay
                    var leftShift = `${((this.video.offsetWidth / 2) - (this.overlay.width / 2))}px`;
                    this.overlay.style.left = leftShift;
                    this.overlay.style.top = '0px';
                    this.frameCanvas.style.margin = "0px " + leftShift;
                    this.selectionSVG.style.margin = "0px " + leftShift;
                } else {
                    this.resizeFrameSize(this.video.offsetWidth, parseFloat(this.video.offsetWidth / imgRatio));
                    //shift the overlay
                    var topShift = `${((this.video.offsetHeight / 2) - (this.overlay.height / 2))}px`
                    this.overlay.style.top = topShift;
                    this.overlay.style.left = '0px';
                    this.frameCanvas.style.margin = topShift + " 0px";
                    this.selectionSVG.style.margin = topShift + " 0px";
                }
            },
            resizeFrameSize: function (width, height) {
                this.frameWidth = width;
                this.frameHeight = height;
                this.overlay.width = this.frameWidth;
                this.overlay.height = this.frameHeight;
                this.frameCanvas.width = this.frameWidth;
                this.frameCanvas.height = this.frameHeight;
                this.areaSelector.resize(width, height);
                this.regionsManager.resize(width, height);
            },
            resetLayout: function () {
                this.overlay.style.top = "";
                this.overlay.style.left = "";
                this.frameCanvas.style.margin = "";
                this.selectionSVG.style.margin = "";
            },
            disableImageDir: function () {
                $("#rotate").hide();
                $(window).off("resize");
                this.imageIndex = 0;
                this.imagelist = undefined;
                this.video.removeAttribute("poster");
                this.src = "";
            },
            rotate: function () {
                this.rotation = (this.rotation + 90) % 360;
                $('#vid').css("transform", `rotate(${this.rotation}deg)`);
            },
            seekToFrame: function (id, fireEvents = true) {
                if (this.checkRegionLabels()) {
                    //raise before next frame
                    this.prevFrameIndex = this.getCurrentFrameNumber();
                    if (this.imagelist) {//image handling
                        if (this.imageIndex == id - 1) {
                            //Only fire before step if seeking to the next frame
                            if (fireEvents) $('#video-tagging').trigger('stepFwdClicked-BeforeStep');
                        }
                        if (this.imageIndex == id + 1) {
                            //Only fire before step if seeking to the previous frame
                            if (fireEvents) $('#video-tagging').trigger('stepBwdClicked-BeforeStep');
                        }
                        if (id < this.imagelist.length - 1) {
                            this.imageIndex = id;
                            if (this.recordlist) {
                                this.currTFRecord = this.recordlist[this.imageIndex];
                                this.addNewRecordTags();
                                this.optionalTags.createTagControls(this.inputtagsarray);
                                this.changeImage(this.currTFRecord.features.feature['image/encoded'].bytesList.value[0], true);
                            }
                            else this.changeImage(`url(file://${this.imagelist[this.imageIndex].replace(/\\/g, "/")})`);
                            //this.playingCallback();
                        }
                    } else { //video handling
                        //TODO: This is never called, so why is it here?
                        if (!this.video.paused) this.pauseState();
                        if ((this.video.currentTime + this.frameTime) > this.video.duration) {
                            //this.video.currentTime = this.video.duration;
                            return;
                        }
                        if (!this.canMove) return;
                        if (fireEvents) $('#video-tagging').trigger('stepFwdClicked-BeforeStep');
                        //if there are no unlabled tags move to next frame
                        this.video.currentTime += this.frameTime;
                        this.playingCallback();
                    }
                    //raise after next frame
                    if (fireEvents) $('#video-tagging').trigger('stepFwdClicked-AfterStep');
                }
            },
            stepFwdClicked: function (fireEvents = true) {
                if (this.checkRegionLabels()) {
                    //modify
                    //console.log(this.getCurrentFrameNumber());
                    //获得上一帧数
                    this.prevFrameIndex = this.getCurrentFrameNumber();
                    this.cleanSelectedElements()
                    //raise before next frame
                    if (fireEvents) $('#video-tagging').trigger('stepFwdClicked-BeforeStep');
                    if (this.imagelist) {//image handling 
                        if (this.imageIndex < this.imagelist.length - 1) {
                            this.imageIndex++;
                            if (this.recordlist) {
                                this.currTFRecord = this.recordlist[this.imageIndex];
                                if (this.currTFRecord) this.addNewRecordTags();
                                this.optionalTags.createTagControls(this.inputtagsarray);
                                this.changeImage(this.currTFRecord.features.feature['image/encoded'].bytesList.value[0], true);
                            }
                            else this.changeImage(`url(file://${this.imagelist[this.imageIndex].replace(/\\/g, "/")})`);
                        }
                    } else { //video handling
                        if (!this.video.paused) this.pauseState();
                        if ((this.video.currentTime + this.frameTime) > this.video.duration) {
                            return;
                        }
                        //if there are no unlabled tags move to next frame
                        this.video.currentTime += this.frameTime;
                        this.playingCallback();
                    }
                    //raise after next frame
                    if (fireEvents) $('#video-tagging').trigger('stepFwdClicked-AfterStep');
                }
            },
            stepBwdClicked: function (fireEvents = true) {
                if (this.checkRegionLabels()) {
                    this.prevFrameIndex = this.getCurrentFrameNumber();
                    this.cleanSelectedElements();
                    if (fireEvents) $('#video-tagging').trigger('stepBwdClicked-BeforeStep');
                    if (this.imagelist) {//image handling
                        if (this.imageIndex > 0) {
                            this.imageIndex--;
                            if (this.recordlist) {
                                this.currTFRecord = this.recordlist[this.imageIndex];
                                this.addNewRecordTags();
                                this.optionalTags.createTagControls(this.inputtagsarray);
                                this.changeImage(this.currTFRecord.features.feature['image/encoded'].bytesList.value[0], true);
                            }
                            else this.changeImage(`url(file://${this.imagelist[this.imageIndex].replace(/\\/g, "/")})`);
                        }
                    }
                    if (this.video.currentTime > 0) {
                        if (!this.video.paused) {
                            this.pauseState();
                        }
                        if (this.checkRegionLabels()) {
                            this.video.currentTime -= this.frameTime;
                            this.playingCallback();
                        }
                    }
                    if (fireEvents) $('#video-tagging').trigger('stepBwdClicked-AfterStep');
                }
            },
            videoSrcChanged: function (newValue, oldValue) {
                if (this.video) {
                    if (this.imagelist) {
                        this.initImageDir();
                    } else {
                        this.video.src = newValue;
                        this.video.style.backgroundImage = null;
                    }
                }
            },
            videoClicked: function (e) {
                this.cleanSelectedElements();
                if (!((this.regiontype.toLowerCase() === "square") || (this.regiontype.toLowerCase() === "rectangle"))) {
                    var rect = this.overlay.getBoundingClientRect();
                    var x1 = (e.clientX - rect.left) / (rect.right - rect.left) * this.overlay.width;
                    var y1 = (e.clientY - rect.top) / (rect.bottom - rect.top) * this.overlay.height;
                    this.createRegion(x1, y1, null, null);
                }
            },
            playState: function () {
                if (!this.imagelist) {
                    //modify
                    //从播放速度下拉框中选出播放速度，设置给源视频
                    this.video.playbackRate = $("#playSpeed").val();
                    this.video.play();
                    this.playing = setInterval(function () {
                        self.playingCallback();
                    }, 10);
                } else {
                    this.sequencePlaying = true;
                    this.playing = setInterval(function () {
                        self.playImageSquence();
                    }, 33);
                }
                this.playButton.classList.toggle("icon-pause2", !this.video.paused || this.sequencePlaying);
                //Reset lock tags to off
                this.lockTagsEnabled = true;
                this.lockTagsClicked();
                this.optionalTags.toggleEnableButtons(false);
                // $('canvas#overlay').imgAreaSelect({disable: true});//disable canvas
                var self = this;
            },
            pauseState: function () {
                if (!this.imagelist) {
                    this.video.pause();
                    this.video.currentTime = Math.floor(this.video.currentTime / this.frameTime) * this.frameTime;//keep the frame in sync
                } else {
                    this.sequencePlaying = false;
                }
                clearInterval(this.playing);
                this.playingCallback();
                this.playButton.classList.toggle("icon-pause2", !this.video.paused || this.sequencePlaying);
                this.optionalTags.toggleEnableButtons(false);
                // $('canvas#overlay').imgAreaSelect({disable: false});//enable canvas
            },
            playingCallback: function () {
                if (!this.imagelist) {
                    this.frameText.value = this.getCurrentFrameNumber();
                    this.displayVideoTime();
                    if (!this.seeking) {
                        this.updateSeekBar();
                    }
                    // Update canvas image based on new video frame
                    this.updateFrameCanvas(this.video);
                } else {
                    this.frameText.value = `${this.getCurrentFrameNumber() + 1}`;
                    if (!this.seeking) {
                        this.updateSeekBar();
                    }
                    // Update canvas image based on new video frame
                    this.updateFrameCanvas(this.curImg);
                }
                this.showAllRegions();
            },
            playImageSquence: function () {
                if (this.imageIndex == this.imagelist.length - 1) {
                    this.pauseState();
                }
                if (this.sequencePlaying) {
                    this.stepFwdClicked();
                }
            },
            displayVideoTime: function () {
                var currentTime = Math.round(this.video.currentTime);
                var remainingtTime = Math.round(this.video.duration - this.video.currentTime);
                //Format using moment.js
                currentTime = moment().startOf('day').seconds(currentTime).format('HH:mm:ss');
                remainingtTime = moment().startOf('day').seconds(remainingtTime).format('HH:mm:ss');
                this.timeSpan.innerHTML = currentTime + "  /  " + remainingtTime;
            },
            updateSeekBar: function () {
                if (this.imagelist) { //image list handling
                    if (!this.seekBar.max)
                        this.seekBar.max = this.imagelist.length - 1;
                    this.seekBar.value = this.getCurrentFrameNumber();
                } else { //video handling
                    this.seekBar.value = this.video.currentTime;
                }
                var perc = 100 * this.seekBar.value / this.seekBar.max;
                this.seekStyle.textContent = '.seek::-webkit-slider-runnable-track{background-size:' + perc + '% 100%}';
                this.seekStyle.textContent += '.seek::-moz-range-track{background-size:' + perc + '% 100%}';
            },
            updateFrameCanvas: function (source) {
                var context = this.frameCanvas.getContext('2d');
                var self = this;
                if (source instanceof HTMLVideoElement || source instanceof HTMLImageElement) {
                    var buff = document.createElement('canvas');
                    buff.width = this.frameWidth;
                    buff.height = this.frameHeight;
                    buff.getContext('2d').drawImage(source, 0, 0, this.frameWidth, this.frameHeight);
                    this.filterPipeline.applyToCanvas(buff).then((bcnvs) => {
                        // Copy buffer to the canvas on screen
                        this.frameCanvas.width = bcnvs.width;
                        this.frameCanvas.height = bcnvs.height;
                        let imgContext = this.frameCanvas.getContext("2d");
                        imgContext.drawImage(bcnvs, 0, 0, bcnvs.width, bcnvs.height);
                    });
                }
            },
            addFilterByName(filterName, params) {
                switch (filterName) {
                    case "invert_filter": {
                        this.filterPipeline.addFilter(this.CT.Filter.InvertFilter);
                        this.playingCallback();
                        break;
                    }
                    case "grayscale_filter": {
                        this.filterPipeline.addFilter(this.CT.Filter.GrayscaleFilter);
                        this.playingCallback();
                        break;
                    }
                    case "reset": {
                        this.filterPipeline.clearPipeline();
                        this.playingCallback();
                        break;
                    }
                    default: {
                    }
                }
            }
        });
    </script>
    <script src="../jquery/dist/jquery.min.js"></script>
    <script src="../moment/moment.js"></script>
    <script src="js/jquery.imgareaselect.js"></script>
    <script src="../jquery-ui/jquery-ui.min.js"></script>
    <!-- <script src="js/ct.min.js"></script> -->
    <script src="js/ct.js"></script>
</dom-module>